\section{Описание}

Жадные алгоритмы - алгоритмы, предполагающие принятие локально оптимальных решений на каждом этапе, допуская, что конечное решение также окажется оптимальным. В общем случае жадные алгоритмы могут не находить глобального оптимума, однако в некоторых задачах позволяют это сделать.

Для моей задачи алгоритм выглядит так:

Во время ввода масива считаем количество единичек, двоек и троек. Таким образом мы можем разбить мысленно массив на три блока, где в первом должны находиться только единицы, во втором только двойки, в третьем - тройки. Причем длина первого блока будет равняться количеству единичек и т.д. 

Далее мы проходимся по массиву слева направо. Если мы в первом блоке встречаем единицу, то идем дальше, если встречаем двойку, значит существует единица, которая не на своем месте. Пытаемся ее найти во втором блоке, так как в таком случае при обмене сразу два элемента встанут на свои места и нам понадобиться сделать лишь одно действие. Если же во втором блоке не нашлось единицы, то ищем в третьем блоке, где она точно есть. Если в первом блоке мы встретили тройку, то шаги аналогичные, только сначала пытаемся найти единицу в третьем блоке, а потом во втором блоке. Когда мы оказываемся во втором блоке, все единицы уже на своем месте, следовательно, встретив тройку, достаточно лишь найти двойку в третьем блоке и обменять. На самом деле можно в этом случае не обменивать (и не искать) тройку и двойку, а просто посчитать количество троек во втором блоке и прибывить к ответу, однако я придержался концепции, что в итоге массив должен быть тоже отсортирован, хотя этого и не требуется.

Сложность такого алгоритма $O(n^{2})$, так как нам надо пройтись по всем числам из первого и второго блоков, которых, если считать, что количество элементов равное, $\frac{2n}{3}$ и для каждого элемента, стоящего не на своем месте за O(n) искать.
\newpage

\section{Исходный код}

\begin{lstlisting}[language=c++]
int main() {

	size_t n = 0;
	cin >> n;

	short* numbers = new short[n];
	size_t one_two_three[3] = {0, 0, 0};

	for (size_t i = 0; i < n; i++) {
		cin >> numbers[i];
		one_two_three[numbers[i]-1]++;
	}

	size_t result = 0;
	for (size_t i = 0; i < n; i++) {

		if (i < one_two_three[0]) {

			if (numbers[i] == 2) {
				for (size_t j = one_two_three[0]; j < n; j++) {
					if (numbers[j] == 1) {
						numbers[i] = 1;
						numbers[j] = 2;
						result++;
						break;
					}
				}
			} else if (numbers[i] == 3) {
				for (size_t j = one_two_three[0] + one_two_three[1]; j < n; j++) {
					if (numbers[j] == 1) {
						numbers[i] = 1;
						numbers[j] = 3;
						result++;
						break;
					}
				}

				if (numbers[i] == 3) {
					for (size_t j = one_two_three[0]; j < one_two_three[0] + one_two_three[1]; j++) {
						if (numbers[j] == 1) {
							numbers[i] = 1;
							numbers[j] = 3;
							result++;
							break;
						}
					}
				}
			}

		} else if (i < one_two_three[0] + one_two_three[1]) {

			if (numbers[i] == 3) {
				for (size_t j = one_two_three[0] + one_two_three[1]; j < n; j++) {
					if (numbers[j] == 2) {
						numbers[i] = 2;
						numbers[j] = 3;
						result++;
						break;
					}
				}
			}

		}

	}

	cout << result << endl;

	delete[] numbers;
	return 0;
}
\end{lstlisting}

\pagebreak

\section{Консоль}
\begin{alltt}
igor@igor-Aspire-A315-53G:~/Рабочий стол/c++/DA/lab8$ cat tests/test1.txt
141
1 1 3 2 3 3 2 1 2 2 2 3 1 1 1 1 3 1 3 1 2 2 1 3 3 3 2 1 2 2 1 3 1 3 2 2 3 1 1 2 2 1 2 3 3 1 1 1 2 1 1 2 2 2 2 3 2 3 3 3 2 2 1 2 3 2 2 2 1 3 1 2 1 2 3 1 1 1 1 1 2 3 3 1 1 3 3 1 1 3 3 3 3 2 3 2 2 1 3 1 2 2 1 2 3 1 2 3 2 1 3 1 3 2 2 2 2 1 1 2 2 3 3 2 1 2 1 2 2 2 2 3 1 1 1 1 3 3 1 1 2
igor@igor-Aspire-A315-53G:~/Рабочий стол/c++/DA/lab8$ ./main.out < tests/test1.txt
47
igor@igor-Aspire-A315-53G:~/Рабочий стол/c++/DA/lab8$ ./main.out
3
3 2 1
1
igor@igor-Aspire-A315-53G:~/Рабочий стол/c++/DA/lab8$
\end{alltt}
\pagebreak
